---
draft: false
date: 2024-06-01
categories:
  - k8s
authors:
  - junho
---

* Kubernetes Core Concept


- [Kubernetes Component](#kubernetes-component)
  - [Master Node](#master-node)
  - [Worker Node](#worker-node)
  - [Pod](#pod)
  - [Service](#service)
  - [Ingress](#ingress)
    - [traffic flow](#traffic-flow)
    - [Ingress Controller](#ingress-controller)
    - [Minikube ingress implementation](#minikube-ingress-implementation)

While I've been using kubectl commands to manage services within a clusterâ€”such as ingress, service, and pod componentsâ€”I've realized that my understanding of their underlying concepts remains somewhat superficial. I'm interested in comprehending how these components interconnect and how clients access the cluster through endpoints. I've tried to delve deeper into details of each component.

- <a href="https://kubernetes.io/docs/concepts/overview/components/" target="_blank">Kubernetes doc</a>
- <a href="https://youtu.be/s_o8dwzRlu4?si=cz3-XlNOq91CUyz8&t=104">Kubernetes by Nana-1hr</a>
- <a href="https://www.youtube.com/watch?v=X48VuDVv0do&t=1594s&ab_channel=TechWorldwithNana" target="_blank">Kuberentes by Nana-3hr</a>
- <a href="https://medium.com/devops-mojo/kubernetes-objects-resources-overview-introduction-understanding-kubernetes-objects-24d7b47bb018" target="_blank">Kubernetes â€” Objects</a>

## Kubernetes Component

|<img src="https://kubernetes.io/images/docs/components-of-kubernetes.svg" alt="add-node" width="820">|
|:--:| 
| *components-of-kubernetes* |

### Master node

- runs the control plane components, monitor and manage overall state of the cluster and resources
- schedule and start pods
- 4 processes run on every master node:
- `kube-apiserver`
  - exposes the Kubernetes API and provides the front end to the Control Plane.
  - a single entrypoint (cluster gateway) for interacting with the k8s control plane
  - handles api requests, authentication, and authorization
  - acts as a gatekeeper for authentication
    - request â†’ api server â†’ validates request â†’ other processes â†’ pod creation
  - UI (dashboard), API(script,sdk), CLI (kubectl)
- `kube-scheduler`
  - schedule new pod â†’ api server â†’ scheduler
  - â†’ intelligently decide which node to put the new Pods based on resource percentage of nodes being used
  - scans for newly created pods and assigns them nodes based on a variety of factors
    - including resource requirements, hardware/software constraints and data locality.
  - distribute workloads across worker nodes
- `kube-controller-manager`
  - ensures the cluster remains in the desired state
  - run controllers which run loops to ensure the configuration matches actual state of the running cluster.
  - these controllers are as follows:
    - Node controller â€” Checks and ensures nodes are up and running
    - Job Controller â€” Manages one-off tasks
    - Endpoints Controller â€” Populates endpoints and joins services and pods.
    - Service Account and Token Controller â€” Creation of accounts and API Access tokens.
  - detect cluster state changes(pods state)
  - Controller Manager(detect pod state) â†’ Scheduler â†’ Kublet(on worker node)
- `cloud-controller-manager`
- `etcd`
  - consistent and highly-available key-value store that maintains cluster state and ensures data consistency
  - cluster brain!
  - key-value data store of cluster state
  - cluster changes get stored in the key value store!
  - Is the cluster healthy? What resources are available? Did the cluster state change?
  - NO application data is stored in etcd!
  - can be replicated
  - Multiple master nodes for secure storage
    - api server is load balanced
    - distributed storage across all the master nodes

### Worker node

- host multiple pods which are the components of the application workload
- the following 3 processes must be installed on every node:
- `kubelet`
  - schedules pods and containers
  - interacts with both the container and node
  - starts the pod with a container inside
  - agent running on each node
  - watches for changes in pod spec and takes action
  - ensures the pods running on the node are running and are healthy.
- `kube-proxy`
  - forwards requests to services to pods
  - intelligent and performant forwarding logic that distributes request to pods with low network overhead
    - it can forward pod request for a service into the pod in the same node instead of forwarding to pods in other nodes, therefore lowers possible network overhead.
  - a daemon on each node that allows network rules such as load balancing and routing
  - enables communication between pods and external clients
  - Proxy network running on the node that manage the network rules
  - and communication across pods from networks inside or outside of the cluster.
- `Container runtime`
  - responsible for pulling images, creating containers
  - e.g. containerd

- https://kubernetes.io/docs/concepts/architecture/

|<img src="https://kubernetes.io/images/docs/kubernetes-cluster-architecture.svg" alt="add-node" width="820">|
|:--:| 
| *kubernetes-cluster-architecture* |


- Example of Cluster Set-up
  - 2 Master nodes, 3 Worker nodes
  - Master node : less resources
  - Worker node : more resources for running applications
  - can add more Master or Worker nodes

### Pod

- "Pods are the smallest deployable units of computing that you can create and manage in Kubernetes."
- abstraction over container
- usually 1 application(container) per pod
- each pod gets its own ip address
- ephermeral; new (unique) ip for each re-creation

### Service

- <a href="https://youtu.be/s_o8dwzRlu4?si=JA5oLELcsrNUdCYn&t=739" target="_blank">Service & Ingress</a>
- Service provide stable(permanent) IP address. Each pod has its own ip address, but are ephemeral.
- Load balancing
- loose coupling
- within & outside cluster
- pods communite with each other using services
- external service
  - http://node-ip:port
- internal service
  - http://db-service-ip:port

- ClusterIP services
  - default type
  - microservice app deployed

### Ingress

Ingress is an object that allows external traffic to reach services within a cluster. It acts as a single entry point for incoming traffic, routing it to the appropriate services based on rules defined via the Kubernetes API1. Here are the key points about Ingress:


- Purpose:
  - Expose Services: Ingress exposes HTTP and HTTPS routes from outside the cluster to services within the cluster.
  - Traffic Routing: Traffic routing is controlled by rules defined on the Ingress resource.
- Capabilities:
  - URL Mapping: An Ingress can give services externally-reachable URLs.
  - Load Balancing: It can load balance traffic.
  - SSL/TLS Termination: Ingress can terminate SSL/TLS connections.
  - Virtual Hosting: It offers name-based virtual hosting.
- Controller: An Ingress controller (usually backed by a load balancer) fulfills the Ingress rules.

- [ibm technology](https://www.youtube.com/watch?v=NPFbYpb0I7w&ab_channel=IBMTechnology)
- [youtube LINK1](https://youtu.be/80Ew_fsV4rM?si=xAS60zSQzhhAEcnb)
- [youtube LINK2](https://youtu.be/X48VuDVv0do?si=K1BDcMdSDNyIK1Ck&t=7312)
- [youtube LINK3](https://www.youtube.com/watch?v=y5-u4jtflic&ab_channel=TTABAE-LEARN)
- [youtube LINK4-Service & Ingreess](https://youtu.be/s_o8dwzRlu4?si=JA5oLELcsrNUdCYn&t=739)
- `https://my-app.com` (ingress can configure secure https protocal with domain name) â†’ forwards traffic into `internal` service
- [ingress by traefik.io](https://traefik.io/glossary/kubernetes-ingress-and-ingress-controller-101/#:~:text=A%20Kubernetes%20ingress%20controller%20follows,state%20requested%20by%20the%20user)
- [gke ingress](https://thenewstack.io/deploy-a-multicluster-ingress-on-google-kubernetes-engine/?ref=traefik.io)
- [load balancer and ingress duo](https://medium.com/@rehmanabdul166/explaining-load-balancers-and-ingress-controller-a-powerful-duo-bca7add558ab)
- [load balancer vs. ingress](https://medium.com/@thekubeguy/load-balancer-vs-ingress-why-do-we-need-both-for-same-work-3ae2b9afdd5a)


### Traffic flow

- Let's walk through the flow of traffic in a Kubernetes environment with:
  - Ingress
  - Ingress Controller
  - external Load Balancer (such as an Application Load Balancer, ALB):

1. **Ingress Creation**:
   - You start by creating an Ingress resource in your Kubernetes cluster.
   - The Ingress defines routing rules based on HTTP hostnames and URL paths.

2. **External Load Balancer (ELB) Creation**:
   - When you create an Ingress, the cloud environment (e.g., AWS) automatically provisions an external Load Balancer (e.g., ALB).
   - The ELB acts as the entry point for external traffic.

3. **Traffic Flow**:
   - Here's how the traffic flows:
     - **External Client**: Sends a request to the ALB (Load Balancer).
     - **ALB**: Receives the request and forwards it to the Ingress Controller.
     - **Ingress Controller**: Based on the Ingress rules, the controller routes the request to the appropriate Kubernetes Service.
     - **Service**: The Service forwards the request to the corresponding Pod(s).

So, the complete flow is: **ALB â†’ Ingress Controller â†’ Ingress â†’ Service â†’ Pod**.

Ingress allows fine-grained routing, and the Ingress Controller ensures that the load balancer routes requests correctly. If you need more complex routing based on HTTP criteria, Ingress is a powerful tool! ğŸš€


1. Use External Service: http://my-node-ip:svcNodePort â†’ Pod
  - service.spec.type=LoadBalancer, nodePort=30510
  - http://localhost:30510/
    - in VirtualBox port-forward 30510
2. Use `Ingress` + Internal service: https://my-app.com
  - Ingress Controller Pod â†’ Ingress (routing rule) â†’ Service â†’ Pod
  - using ingress, you can configure https connection


### Ingress Explained

1. External Service (without Ingress)

```yaml
apiVersion: v1
kind: Service
metadata:
  name: myapp-external-service
spec:
  selector:
    app: myapp
  # LoadBalancer : opening to public
  type: LoadBalancer
  ports:
    - protocol: TCP
      port: 8080
      targetPort: 8080
      nodePort: 30510
```

2. Using Ingress â†’ internal Service (e.g. `myapp-internal-service`)
  - internal service has no `nodePort` and the type should be `type: ClusterIP`
  - must be valid domain address
  - map domain name to Node's IP address, which is the entrypoint
    - (one of the nodes or could be a host machine outside the cluster)

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: myapp-ingress
spec:
  rules:
  - host: myapp-com
    http:
      # incoming requests are forwarded to the internal service
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: myapp-internal-service
            port: 8080

---
apiVersion: v1
kind: Service
metadata:
  name: myapp-internal-service
spec:
  selector:
    app: myapp
  ports:
    - protocol: TCP
      port: 8080
      targetPort: 8080
```

### Ingress controller

- implementation of ingress, which is Ingress Controller (Pod)
- evaluates and processes ingress rules
- manages redirections
- entrypoint to cluster
- many third party implementations
  - e.g. k8s Nginx Ingress Controller
- HAVE TO CONSIDER the environemnt where the k8s cluster is running
  - Cloud Service Provider (AWS, GCP, AZURE)
    - External reqeust from the browser â†’
      - Cloud Load balancer â†’
      - Ingress Controller Pod â†’
      - Ingress â†’
      - Service â†’
      - Pod
    - using cloud lb, you do not have to implement load balancer yourself
  - Baremetal
    - you need to configure some kind of entrypoint (e.g. metallb)
    - either inside of cluster or outside as separate server
    - software or hardware solution can be used
    - must provide entrypoint
    - e.g. Proxy Server: public ip address and open ports
      - Proxy server â†’ Ingress Controller Pod â†’ Ingress (checks ingress rules) â†’ Service â†’ Pod
      - no server in k8s cluster is publicly accessible from outside


### Minikube ingress implementation

```sh
# nginx implementation of ingress controller
minikube addons enable ingress

k get pod -n kube-system
  nginx-ingess-controller-xxx

```

- configure ingress rule for kubernetes dashboard componnent
  - minikube in default creates dashboard service (minikube specific)

```sh
k get ns
  kubernetes-dashboard Active 17d

k get all -n kubernetes-dashboard
  pod
  svc
```

- dashboard-ingress.yaml

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: dashboard-ingress
  namespace: kubernetes-dashboard
spec:
  rules:
  - host: dashboard.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            # forward to service name created in minikube
            name: kubernetes-dashboard
            port:
              number: 80
```

- create ingress rule for kubernetes-dashboard

```sh
k apply -f dashboard-ingress.yaml

k get ingress -n kubernetes-dashboard --watch
  NAME               CLASS   HOSTS             ADDRESS        PORTS   AGE
  dashboard-ingress  nginx   dashboard.com     192.168.49.2   80      42s

vim /etc/hosts
  192.168.49.2 dashboard.com

# check in chrome browser:
# http://dashboard.com

k describe ingress dashboard-ingress -n kubernetes-dashboard

  # whenever there's a request into the cluster, there's no rule for mapping the request to service, then
  # this backend is default to handle the request. e.g. 404 not found
  # one can define custom error page
  # SIMPLY CREATE A SERVICE WITH THE SAME NAME: default-http-backend
  Default backend: default-http-backend:80
```

- Define custom `default-http-backend`

```yaml
apiVersion: v1
kind: Service
metadata:
  name: default-http-backend
spec:
  selector:
    app: default-response-app
  ports:
    - protocol: TCP
      # this is the port that receives the default backend response
      port: 80
      targetPort: 8080
```

- ingress rules

- multiple paths for the same host
  - http://myapp.com/analytics
  - http://myapp.com/shopping

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: simple-fanout-example
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
spec:
  rules:
  - host: myapp.com
    http:
      paths:
      - path: /analytics
        pathType: Prefix
        backend:
          service:
            name: analytics-service
            port:
              number: 3000
      - path: /shopping
        pathType: Prefix
        backend:
          service:
            name: shopping-service
            port:
              number: 8080
```


- multiple hosts
  - http://analytics.myapp.com
  - http://shopping.myapp.com

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: simple-fanout-example
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
spec:
  rules:
  - host: analytics.myapp.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: analytics-service
            port:
              number: 3000
  - host: shopping.myapp.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: shopping-service
            port:
              number: 8080
```


- Ingress that includes configuration of TLS certificate
  - Secret component : define yaml to create one
    - tls.crt, tls.key : values are actual file contents, NOT file paths/locations
    - Secret must bein the same namepsace as the Ingress Component

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: tls-example-ingresss
spec:
  ########## TLS SETTING ##########
  tls:
  - hosts:
    - myapp.com
    secretName: myapp-secret-tls
  ########## TLS SETTING ##########
  rules:
  - host: myapp.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: myapp-internal-service
            port:
              number: 8080
---
apiVersion: v1
kind: Secret
metadata:
  name: myapp-secret-tls
  namespace:default
data:
  tls.crt: base64 encoded cert
  tls.key: base64 encoded key
type: kubernetes.io/tls
```



- ConfigMap
  - stored in plaintext format
  - external configuration of your application
  - `DB_URL = monngo-db`

- Secret
  - Caution: "Kubernetes Secrets are, by default, stored unencrypted in the API server's underlying data store (etcd)."
    - https://kubernetes.io/docs/concepts/configuration/secret/
  - stored in base64 encoded format
  - `DB_USER = mongo-user`
  - `DB_PW = mongo-pw`

- Volume (like an external hdd plugged into cluster)
  - k8s does not manage data persistence
  - if database pod dies the data disappears
  - it requires persistent database
  - strorage could on:
    - on Local
    - on Remote, outside of the cluster


- What if pod dies => downtime occurs.
  - use service as a load balancer which distributes traffic to multiple nodes
  - Use multi-node and pod replicas(deployment as abstraction for pods)
  - deployment specifies how many pods are deployed into multiple nodes
  - BUT, database pods cannot be replicated. it requires to store data into a single storage
    - use StatefulSet for stateful apps such as Databases

- `Deployemnt` for stateless apps
  - Deployment is the Abstraction of Pods

- `StatefulSet` for stateFul apps or databases
  - DB can't be replicated via deployment.
  - Avoid data inconsistencies
  - => StatefulSet for STATEFUL apps. e.g. mysql, mongodb, elastic search
  - But deploying StatefulSet is not easy
  - `NOTE`: "DB are often hosted outside of k8s cluster"

- Minikube
  - master and worker process run on a single node
  - usually via virtual box or other hypervisor
  - for testing purposes

- deployment
  - blueprint for creating pods
  - most basic configuration for deployemnt (name and image to use)
  - rest defaults

- replicaset
  - another abstraction of layer
  - manages the replicas of a pod

```sh
k create deployment nginx-depl --image=nginx:alpine
k get replicaset
```


- Layers of Abstraction
  - Deployment : manages a replicaset
  - ReplicaSet : manages replicas of pods
  - Pod : is an abstraction of containers
  - Container

```sh
# edit deployement, but not pod directly
k edit deployment nginx-depl
```


- YAML configuration file
  - Attributes of `spec` are specific to the `kind`
  - each configuration file has 3 parts
    - metadata
    - specification
    - status: automatically generated by k8s (desired ==? actual) self-healing feature
      - k8s gets this status from `etcd`!
  - Store the YAML config file with your code (git repository)
  - `template` also has its own `metadata` and `spec`: applies to Pod
    - blueprint for a Pod


- Connecting the component
  - labels & selectors
  - `metadata` contains labels, `spec` contains selectors
    - metadata define key-value pair for label which is matched by the spec selector for pod
    - pod gets the label through the spec.template blueprint
    - pod belongs to deployment by label
    - deployment labels are connected to service's spec.selector
    - service's spec.selector uses deployment's metadata labels to make connection to deployement(pods)
  - service expose port (accessible) â†’ forward to service targetPort â†’ deployment's containerPort

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: fe-nginx-deployment
  # NOTE label for deployment which is used by service to make connection to deployement(pods)
  labels:
    app: fe-nginx
spec:
  replicas: 2
  selector:
    # NOTE allows `Deployment` to find and manage Pods with this matching label
    matchLabels:
      app: fe-nginx
  template:
    metadata:
      # NOTE sets the labels for the `Pods` created by the Deployment.
      labels:
        app: fe-nginx
    spec:
      containers:
      - name: fe-nginx
        image: jnuho/fe-nginx:latest
        imagePullPolicy: IfNotPresent
        ports:
        - containerPort: 80
      #imagePullSecrets:
      #- name: regcred
```


```sh
k describe svc serivceName
  Endpoints: podip:targetPort
  : this Endpoint ip matches pod ip

k get pod podName -o wide
k get deploy nginx-depl -o yaml
  check the status is automatically generated by k8s
  retrieve result of status from etcd
```

- Complete Application setup with Kubernetes components
  - mongodb(internal service; no external requests), mongo-express(Web-app)
  - mongo express get url,id, pw from configmap and secret to connect to mongodb
  - mongo express accessible from browser: NodeIp:PortOfExternalService
  - 2 Deployment / Pod
  - 2 Service
  - 1 ConfigMap
  - 1 Secret
  - Browser â†’ mongo express external service â†’ mongoexpress pod â†’ mongodb internal service â†’ mongodb pod


- Namespace
  - kube-system: system processes, master and kubectl processes
  - kube-public: publicly accessible data, configmap, that contains cluster information `k cluster-info`
  - kube-node-lease: heartbeats of node, determines the availability of a node
  - default: resources you create

```sh
kubectl create namespace myNameSpace
```

- Group applications into namespaces
  - e.g. database/ logging / monitoring/ nginx-ingress/elastic stack
  - no need to create namespaces for smaller projects with about 10 users
  - create namespaces if there are many teams, same application(same name)
  - staging/development namespace resources use same resource in certain namespaces
  - blue/green deployment using namespaces (Production green/blue)
  - access and resource limits on nameaspaces


- Each NS must define own ConfigMap/Secret
  - suppose projectA, projectB namespaces
  - both namespace must have ConfigMap with exact same content

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: mysql-configmap
data:
  db_url: mysql-service.database
```

- Components, which can't be created within a namespace
  - persistent volume
  - node

```sh
k api-resources --namespaced=false
k api-resources --namespaced=true
```


- You can change the active namespace with kubens
  - without a need to `k get pod -n myNameSpace`

```sh
brew install kubectx
kubens
kubens my-namespace
  Active namespace is "my-namespace"
```



- Helm explained
  - package manage (e.g. apt)


- Helm for Elastic Search Stack for Logging
- requirement: yamls for
  - Stateful Set
  - ConfigMap
  - Secret
  - K8s User with permissions
  - Services
- First, helm provide packages for those to be used by anyone
  - install bundle of yamls
  - create your own helm charts with helm
  - push them to helm repository
  - download and use existing ones
  - e.g. database apps, monitoring apps(prometheus)
  - sharing helm charts is available
  - you can download reuse that configuration
  - `helm search <keyward>`
  - public/private helm registries
- Second, helm as a templating engine
  - for CI/CD: in your build, you can replace the values on the fly
  - Define a template with common attributes for many configurations
    - a common blueprint defined as a template YAML config
    - dynamic values are replaced by placeholders; `values.yaml`
      - values injection into template files
  - Same applications across different environments


- Helm chart structure

```
tree

mychart/        # name of the chart
  Chart.yaml    # meta info about chart: name,version,dependencies
  values.yaml   # values for the template files(can be overridden)
  charts/       # chart dependencies
  templates/    # template files
  READEME.md
  LICENSE

helm install <chartname>

# override values.yaml default values by:
# values.yaml + my-value.yaml => result
helm install --values=my-values.yaml <chartname>
helm install --set version=2.0.0

# BETTER TO HAVE my-values.yaml and values.yaml instead of `set`
```

- helm release management

- version2 vs. version3
- version2:
  - client  (cli)
  - server (tiller)
  - helm install(cli) â†’ tiller execute yaml and deploy the cluster
  - helm install/upgrade/rollback â†’ tiller create history with revision
    - revision 1,2... history is stored
    - downsides: tiller has too much power inside of k8s cluster
      - security risk
- version3: removed tiller for such security risk


- Volumes
  - Persistent Volume
  - Persistent Volume Claim
  - Storage class

- need for volumes
  - k8s no data persistence out of the box!
  - requires storage that doesn't depend on the pod lifecycle
  - storage must be available on all nodes
  - need to survive even if node/cluster crushes; highly available
    - outside of cluster?
  - writes/reads to directory

- Persistent volume
  - cluster resources used to storage data
  - defined by YAML
  - `spec`: how much storage
  - need actual physical sotrage:
  - persistent volume does not care about your actual storage
    - `pv` simply provides interface to the actual storage
    - it's like an external plugin to your cluster
  - could be hybrid: multiple storage types
    - one application uses local disk/nfs server/cloud stroages, etc.
  - in YAML for `pv`, specify in `spec`, which physical storage to use

- Check types of vlumes in k8s document

- gcp cloud storage

```yaml
apiVersion: v1
kind: PersistentVolume
metadata:
  name: test-volume
  failure-domain.beta.kubernetes.io/zone: us-central1-a__us-central1-b
spec:
  capacity:
    storage: 400Gi
  accessModes:
  - ReadWriteOnce
  gcePersistentDisk:
    pdName: my-data-disk
    fsType: ext4
```

- local storage

```yaml
apiVersion: v1
kind: PersistentVolume
metadata:
  name: example-pv
spec:
  capacity:
    storage: 100Gi
  volumeMode: Filesystem
  accessModes:
  - ReadWriteOnce
  persistentVolumeReclaimPolicy: Delete
  storageClassName: local-storage
  local:
    path: /mnt/disks.ssd1
  modeAffinity:
    required:
      nodeSelectorTerms:
      - matchExpressions:
        - key: kubernetes.io/hostname
          operator: In
          values:
          - example-node
```

- Persistent Volumes are NOT namespaced
  - PV outside of the namesapces
  - accessible to the whole cluster

- Local vs. Remote volume types
  - each volume type has it's own use case!
  - local volume types violoate 2. and 3. requirement for data persistence:
    - (X) Being tied to 1 specific node
    - (X) Surviving cluster crashes
- For DB persistence, almost always use REMOTE STORAGE!!!



- StatefulSet
  - What is it and why it is used?
  - how `StatefulSet` differs from `Deployment`?
  - specifically for stateful appliations!
    - e.g. stateful apps: database apps
    - e.g. stateless apps: don't keep record of state, each request is completely new


- Stateful and stateless applications example
  - nodejs(stateless) + mongodb(stateful)
  - http request (doesn't depend on previous data to handle)â†’ nodejs
    - handle it based on the payload of request
    - update/query from mongodb app
  - mongodb update data based on previous state / query data
    - depends on most up-to-date data/state

- Stateless apps are deployed using `Deployment` component
- Stateful apps are deployed using `StatefulSet` component
- Both `Deployment` and `StatefulSet` manage pods based on container specification!



- K8s Services
  - ClusterIP
  - NodePort
  - LoadBalancer
  - Headless

- each pod has its own ip address
- pods are ephermeral - are descroyed frequently!
- service provides stable ip address.
- service does load balancing into pods
- loose coupling 
- within & outside cluster


- ClusterIP Services
  - default type
  - e.g. microservices app deployed
    - in pod : app container(3000)+sidecar container (9000: collects logs)
    - pod assgiend in node ip range: 10.2.2.5 (started on node2)
    - where node1: 10.2.1.x
    - where node2: 10.2.2.x
    - where node3: 10.2.3.x
    - `k get pod -o wide` to check pod ip
    - Ingress â†’ Service(ClusterIP) â†’ Pods
    - Sevice's `spec.selector` : which Pods it forward to
    - Sevice's `spec.ports.targetPort` : which Ports it forward to
    - Pods are identified via selectors
      - key value pairs for selctor
      - Pod: `spec.template.metadata.labels`
      - Service: `spec.selector`
        - service forwards request to matching Pods
    - Service Endpoint is CREATED with the same name as Service
    - keeps track of which Pods are the members/endppoints of the Service
    - each time pods recreated, Endpoints are also updated to track that
    - Service `spec.ports.port`: can be arbitrary
    - Service `spec.ports.targetPort`: MUST MATCH deployment's Pod `containerPort`
    - Multi-port services (two container specified in deployment.yaml)
      - mongo-db application 27017
      - mongo-db exporter (Prometheus) 9216
        - Prometheus scapes data from mododb-exporter via port 9216
    - service have to handle two requests via two ports 27017, 9216

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: microservice-one
spec:
  replicas: 2
  # ...
  template:
    metadata:
      labels:
        app: microservice-one
    spec:
      containers:
      - name: ms-one
        image: my-private-repo/ms-one:latest
        ports:
        - containerPort: 3000
      - name: log-collector
        image: my-private-repo/log-collector:latest
        ports:
        - containerPort: 9000
```

- Multi-port service

```yaml
apiVersion: v1
kind: Service
metadata:
  name: mongodb-service
spec:
  selector:
    app: mongodb
  ports:
    - name: mongodb
      protocol: TCP
      port: 27017
      targetPort: 27017
    - name: mongodb-exporter
      protocol: TCP
      port: 9216
      targetPort: 9216
```



- Headless Service
  - Client wants to communicate with 1 specific Pod directly
  - Pods want to talk directly with specific Pod
  - So, not randomly selected (no Load balancing)
  - Use case: `Stateful` applications
    - such as databases(mysql,mongodb, elasticsearch)
    - Pods replicas are not identical
    - Only Master Pod is allowed to write to DB (write/read)
    - Worker Pods are for only (read)
    - Worker Pods must connect to Master Pod to sync their data after Master Pods made changes to the data
    - When a Worker Pod is created, it must clone the most recent Worker Pod
  - Client need to figure out IP addresses of each Pod
    - Option 1: API call to k8s API Server?
      - list of pods and ip addresses
      - too tied to k8s api and inefficient
    - Option 2: DNS lookup
      - k8s allows client to discover Pod ip addresses
      - DNS lookup for service - returns single IP address which belongs to a Service (ClusterIP address)
    - BUT setting `sepc.cluseterIP` to `None` returns Pod IP address instead!!!

- Define headless Service:
  - NO CLUSTER IP address is assigned!!!

```yaml
apiVersion: v1
kind: Service
metadata:
  name: mongodb-service-headless
spec:
  clusterIP: None
  selector:
    app: mongodb
  ports:
    - protocol: TCP
      port: 27017
      targetPort: 27017
```

- Two services exist alongside each other
  - `mongodb-service`
  - `mongodb-service-headless`

- Use headles service when client needs to perform write into mongodb Master Pod or for Pods to talk to each other for data synchronization

```sh
k get svc

NAME                     TYPE       CLUSTER-IP EXTERNAL-IP PORT(S)
mongodb-service-headless ClusterIP  None       <none>      27017/TCP
```

- 3 Service `type`
  - ClusterIP: default, internal service, only accessible within cluster
    - no external traffic can directly address the ClusterIP service
  - NodePort: accessible on a static port on each worker node in cluster
    - External traffic has access to fixed port on each Worker Node
    - `nodePort` range should be: 30000 - 32767
    - `http://ip-address-worker-node:nodePort`
    - When you create NodePort Service, ClusterIP Service is also automatically created because nodePort has to be routed to `port` of Service
      - `nodePort` â†’ `port`
      - e.g.  `port:3200`, `nodePort:30008`
        - cluster-ip:3200
        - node-ip:30008
  - LoadBalancer
    - LoadBalancer(Cloud providers')
    - AWS, GCP, AZURE
    - When Service of type LoadBalancer is created,
      - NodePort and ClusterIP Service are created automatically!
      - nodeport is not accessible directly from external browser
        - instead via LoadBalancer!!!

```yaml
apiVersion: v1
kind: Service
metadata:
  name: ms-service-loadbalancer
spec:
  type: LoadBalancer
  selector:
    app: microservice-one
  ports:
    - protocol: TCP
      port: 3200
      targetPort: 3000
      # only via LoadBalancer though!
      nodePort: 30010
```


- LoadBalancer > NodePort > ClusterIP
  - LoadBalancer Service is an extension of NodePort Service
  - NodePort Service is an extension of ClusterIP Service


- Wrap-up
  - NodePort Service NOT for external connection! TEST-ONLY
  - two common practice:
    - Ingress â†’ Service (ClusterIP)
    - LoadBalanceri â†’ Service (ClusterIP)



### Kubernetes Networking

- [Medium Post](https://medium.com/google-cloud/understanding-kubernetes-networking-pods-7117dd28727)
  - [Networking terminology](https://www.digitalocean.com/community/tutorials/an-introduction-to-networking-terminology-interfaces-and-protocols)
  - [Networking - IP, Subnets, CIDR](https://www.digitalocean.com/community/tutorials/understanding-ip-addresses-subnets-and-cidr-notation-for-networking)






- Kubernetes
  - ì»¨í…Œì´ë„ˆ ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´ì…˜ í”Œë«í¼ìœ¼ë¡œ ì»¨í…Œì´ë„ˆ ì–´í”Œë¦¬ì¼€ì´ì…˜ deploy, manage, scaling í”„ë¡œì„¸ìŠ¤ ìë™í™”
  - Kubernetes clusters : ë¦¬ëˆ…ìŠ¤ ì»¨í…Œì´ë„ˆ í˜¸ìŠ¤íŠ¸ë¥¼ clusterë¡œ ê·¸ë£¹í™”í•˜ê³  ê´€ë¦¬
    - on-premise, public/private/hybrid cloudsì— ì ìš©ê°€ëŠ¥
    - ë°”ë¥¸ ìŠ¤ì¼€ì¼ë§ì´ í•„ìš”í•œ cloud-native ì–´í”Œë¦¬ì¼€ì´ì…˜ì— ì í•©í•œ í”Œë«í¼
  - í´ë¼ìš°ë“œ ì•± ê°œë°œì‹œ optimizationì— ìœ ìš©
  - physical ë˜ëŠ” VM í´ëŸ¬ìŠ¤í„°ì— ì»¨í…Œì´ë„ˆë“¤ì„ scheduling í•˜ê³  run í•  ìˆ˜ ìˆìŒ
  - í´ë¼ìš°ë“œ ë„¤ì´í‹°ë¸Œ ì•±ì„ 'ì¿ ë²„ë„¤í‹°ìŠ¤ íŒ¨í„´'ì„ ì´ìš©í•˜ì—¬ ì¿ ë²„ë„¤í‹°ìŠ¤ë¥¼ ëŸ°íƒ€ì„ í”Œë«í¼ìœ¼ë¡œ ì‚¬ìš©í•˜ì—¬ ë§Œë“¤ìˆ˜ ìˆìŒ
  - ì¶”ê°€ ê¸°ëŠ¥ìœ¼ë¡œ:
    - ì—¬ëŸ¬í˜¸ìŠ¤íŠ¸ì— ê±¸ì³ì„œ ì»¨í…Œì´ë„ˆë¥¼ Orchestrate í•  ìˆ˜ ìˆìŒ
    - ì—”í„°í”„ë¼ì´ì¦ˆ ì•±ì‹¤í–‰ì„ ìœ„í•´ ë¦¬ì†ŒìŠ¤ë¥¼ ìµœëŒ€í™”í•˜ì—¬ í•˜ë“œì›¨ì–´ ìš´ìš© ê°€ëŠ¥
    - ì–´í”Œë¦¬ì¼€ì´ì…˜ ë°°í¬ì™€ ì—…ë°ì´íŠ¸ë¥¼ ì œì–´ ë° ìë™í™”
    - Stateful ì•±ì„ ì‹¤í–‰ í•˜ê¸° ìœ„í•´ ìŠ¤í† ë¦¬ì§€ë¥¼ ë§ˆìš´íŠ¸ í•˜ê³  ì¶”ê°€ ê°€ëŠ¥
    - ì»¨í…Œì´ë„ˆ ì• í”Œë¦¬ì¼€ì´ì…˜ê³¼ ë¦¬ì†ŒìŠ¤ë¥¼ scaling í•  ìˆ˜ ìˆìŒ
  - ì¿ ë²„ë„¤í‹°ìŠ¤ëŠ” ë‹¤ë¥¸ í”„ë¡œì íŠ¸ë“¤ê³¼ ê²°í•©í•˜ì—¬ íš¨ìœ¨ì ì¸ ì‚¬ìš©
    - Registry: Docker Registry
    - Networking
    - Telemetry
    - Security: LDAP, SELinux,RBAC, OAUTH with multitenancy layers
    - Automation
    - Services

- Kubernetes Architecture
  - [image1](https://devopscube.com/wp-content/uploads/2022/12/k8s-architecture.drawio-1.png)
  - [image2](https://www.redhat.com/rhdc/managed-files/kubernetes_diagram-v3-770x717_0_0_v2.svg)

- TERMS
  - Control Plane
    - ì¿ ë²„ë„¤í‹°ìŠ¤ ë…¸ë“œë“¤ì„ ì»¨íŠ¸ë¡¤í•˜ëŠ” í”„ë¡œì„¸ìŠ¤ì˜ ì§‘í•©
    - ì—¬ê¸°ì„œ ëª¨ë“  Task í• ë‹¹ì´ ì´ë£¨ì–´ ì§
  - Node : ì»¨íŠ¸ë¡¤ Planeìœ¼ë¡œ ë¶€í„° í• ë‹¹ëœ Taskë¥¼ ìˆ˜í–‰í•˜ëŠ” ë¨¸ì‹ 
  - Pod: 1ê°œì˜ Nodeì— Deployëœ í•œê°œ ì´ìƒì˜ ì»¨í…Œì´ë„ˆë“¤
    - íŒŒë“œì— ìˆëŠ” ì»¨í…Œì´ë„ˆë“¤ì€ IP ì£¼ì†Œ, IPC (inter-process-communication), Hostname, ë¦¬ì†ŒìŠ¤
  - Replication ì»¨íŠ¸ë¡¤ëŸ¬ : ëª‡ê°œì˜ ë™ì¼ pod ì¹´í”¼ë“¤ì´ í´ëŸ¬ìŠ¤í„°ì—ì„œ ì‹¤í–‰ë˜ì–´ì•¼ í•˜ëŠ”ì§€ ì»¨íŠ¸ë¡¤
  - Service : Podsë¡œë¶€í„° work definitionì„ ë¶„ë¦¬í•¨.
    - Kubernetes Service Proxyë“¤ì´ ìë™ìœ¼ë¡œ ì„œë¹„ìŠ¤ ë¦¬í€˜ìŠ¤íŠ¸ë¥¼ podì— ì—°ê²°í•¨
    - Cluster ë‚´ì—ì„œ ì–´ë””ë¡œ ì›€ì§ì´ë“  ë˜ëŠ” replace ë˜ë”ë¼ë„ ìë™ìœ¼ë¡œ ì—°ê²° ë¨.
  - Kubelet : ì´ ì„œë¹„ìŠ¤ëŠ” ë…¸ë“œì—ì„œ ì‹¤í–‰ë˜ë©°, ì»¨í…Œì´ë„ˆ manifestë¥¼ ì½ê³ , ì •ì˜ëœ ì»¨í…Œì´ë„ˆë“¤ì´ ì‹œì‘ë˜ê³  ì‘ë™í•˜ë„ë¡ í•¨

- ë™ì‘ì›ë¦¬
  - í´ëŸ¬ìŠ¤í„° : ë™ì‘ ì¤‘ì¸ ì¿ ë²„ë„¤í‹°ìŠ¤ deploymentë¥¼ í´ëŸ¬ìŠ¤í„°ë¼ê³  í•©ë‹ˆë‹¤.
    - í´ëŸ¬ìŠ¤í„°ëŠ” ì»¨íŠ¸ë¡¤ planeê³¼ compute ë¨¸ì‹ (ë…¸ë“œ) ë‘ê°€ì§€ íŒŒíŠ¸ë¡œ ë‚˜ëˆŒ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
      - Control Plane + Worker nodes
    - ê°ê°ì˜ ë…¸ë“œëŠ” ë¦¬ëˆ…ìŠ¤í™˜ê²½ìœ¼ë¡œ ë³¼ ìˆ˜ ìˆìœ¼ë©°, physical/virtual ë¨¸ì‹ ì…ë‹ˆë‹¤.
    - ê°ê°ì˜ ë…¸ë“œëŠ” ì»¨í…Œì´ë„ˆë“¤ë¡œ êµ¬ì„±ëœ podë“¤ì„ ì‹¤í–‰í•©ë‹ˆë‹¤.
    - ì»¨íŠ¸ë¡¤ëŸ¬ í”Œë ˆì¸ì€ í´ëŸ¬ìŠ¤í„°ì˜ ìƒíƒœë¥¼ ê´€ë¦¬
      - ì–´ë–¤ ì–´í”Œë¦¬ì¼€ì´ì…˜ì´ ì‹¤í–‰ë˜ê³  ìˆëŠ”ì§€, ì–´ë–¤ ì»¨í…Œì´ë„ˆ ì´ë¯¸ì§€ê°€ ì‚¬ìš© ë˜ê³  ìˆëŠ”ì§€ ë“±
      - Compute ë¨¸ì‹ ì€ ì‹¤ì œë¡œ ì–´í”Œë¦¬ì¼€ì´ì…˜ê³¼ ì›Œí¬ë¡œë“œë“¤ì„ ì‹¤í–‰ í•©ë‹ˆë‹¤.
  - ì¿ ë²„ë„¤í‹°ìŠ¤ëŠ” OSìœ„ì—ì„œ ë™ì‘í•˜ë©´ì„œ ë…¸ë“œë“¤ìœ„ì— ì‹¤í–‰ ì¤‘ì¸ ì»¨í…Œì´ë„ˆ podë“¤ê³¼ interact í•©ë‹ˆë‹¤.
    - ì»¨íŠ¸ë¡¤ëŸ¬í”Œë ˆì¸ì€ adminìœ¼ë¡œë¶€í„° ì»¤ë©˜ë“œë¥¼ ë°›ì•„, Computeë¨¸ì‹ ì— í•´ë‹¹ ì»¤ë©˜ë“œë“¤ì„ ì ìš©í•©ë‹ˆë‹¤.


- Youtube Tutorial (TechWorld with Nana)

```
- Deployment > ReplicaSet > Pod > Container
  - use kubectl command to manage deployment

```sh
k get pod

k get services

k create deployment nginx-depl --image=nginx
k get deployment
k get pod
k get replicaset

k edit deployement nginx-depl
k get pod
  NAME                          READY   STATUS    RESTARTS   AGE
  nginx-depl-8475696677-c4p24   1/1     Running   0          3m33s
  mongo-depl-5ccf565747-xtp89   1/1     Running   0          2m10s

k logs nginx-depl-56cb8b6d7-6z9w6

k exec -it [pod name] -- bin/bash

k exec -it mongo-depl-5ccf565747-xtp89 -- bin/bash
k delete deployment mongo-depl
```


- microk8s í™˜ê²½
  - https://microk8s.io/docs/getting-started
  - https://ubuntu.com/tutorials/install-a-local-kubernetes-with-microk8s?&_ga=2.260194125.1119864663.1678939258-1273102176.1678684219#1-overview


```sh
sudo snap install microk8s --classic

# ë°©í™”ë²½ì„¤ì •
# https://webdir.tistory.com/206

sudo usermod -a -G microk8s $USER
sudo chown -f -R $USER ~/.kube
su - $USER
microk8s status --wait-ready

vim .bashrc
  alias k='microk8s kubectl'
  alias helm='microk8s helm'

source .bashrc
```

- Microk8s, Ingress, metallb, nginx controllerë¡œ ì™¸ë¶€ ì„œë¹„ìŠ¤ ë§Œë“¤ê¸°
  - ì°¸ê³  ë¬¸ì„œ
    - https://kubernetes.github.io/ingress-nginx/deploy/baremetal/
    - https://benbrougher.tech/posts/microk8s-ingress/
    - https://betterprogramming.pub/how-to-expose-your-services-with-kubernetes-ingress-7f34eb6c9b5a

- IngressëŠ” ì¿ ë²„ë„¤í‹°ìŠ¤ê°€ ì™¸ë¶€ë¡œ ë¶€í„° íŠ¸ë˜í”½ì„ ë°›ì•„ì„œ ë‚´ë¶€ ì„œë¹„ìŠ¤ë¡œ routeí•  ìˆ˜ ìˆë„ë¡ í•´ì¤Œ
  - í˜¸ìŠ¤íŠ¸ë¥¼ ì •ì˜í•˜ê³ , í˜¸ìŠ¤íŠ¸ë‚´ì—ì„œ sub-routeë¥¼ í†µí•´
  - ê°™ì€ í˜¸ìŠ¤íŠ¸ë„¤ì„ì˜ ë‹¤ë¥¸ ì„œë¹„ìŠ¤ë“¤ë¡œ routeí•  ìˆ˜ ìˆë„ë¡ í•¨
  - Ingress ruleì„ í†µí•´ í•˜ë‚˜ì˜ Ip ì£¼ì†Œë¡œ ë“¤ì–´ì˜¤ë„ë¡ ì„¤ì •
  - Ingress Controllerê°€ ì‹¤ì œ traffic routeí•˜ë©°, IngressëŠ” ruleì„ ì •ì˜í•˜ëŠ” ì—­í• 

- ì´ë¯¸ì§€ ë§Œë“¤ê¸° â†’ Dockerhubì— push

```sh
# ì´ë¯¸ì§€ ë§Œë“¤ê¸°
cd learn/yaml/helloworld/docker
docker build -t server-1:latest -f build/Dockerfile .
docker tag server-1 jnuho/server-1
docker push jnuho/server-1
```

- simple-service.yaml

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: hellok8s-deployment
  labels:
    app: hellok8s
spec:
  replicas: 1
  selector:
    matchLabels:
      app: hellok8s
  template:
    metadata:
      labels:
        app: hellok8s
    spec:
      containers:
      - name: hellok8s
        image: jnuho/server-1
        ports:
        - containerPort: 8081
---
apiVersion: v1
kind: Service
metadata:
  name: hellok8s-service
  # Use specific ip for metallb
  annotations:
    metallb.universe.tf/loadBalancerIPs: 172.16.6.100
spec:
  type: LoadBalancer
  selector:
    app: hellok8s
  ports:
  - port: 8081
    targetPort: 8081
```

```sh
k apply -f simple-service.yaml
k get svc
  NAME               TYPE           CLUSTER-IP      EXTERNAL-IP    PORT(S)          AGE
  kubernetes         ClusterIP      10.152.183.1    <none>         443/TCP          5d19h
  hellok8s-service   LoadBalancer   10.152.183.58   <none>         8081:31806/TCP   114s
```

```sh
# ì‚¬ìš©ì¤‘ ipì¸ì§€ í™•ì¸í•˜ê¸°: 100-105
ping 172.16.6.100

microk8s enable metallb:172.16.6.100-172.16.6.105

# ë¡œë“œë°¸ëŸ°ì„œ ì„œë¹„ìŠ¤ì˜ IPê°€ metallbì— ì˜í•´ í• ë‹¹ë¨
# 172.16.6.100:8081ë¡œ ì• í”Œë¦¬ì¼€ì´ì…˜ ì ‘ê·¼

k get svc
  NAME               TYPE           CLUSTER-IP      EXTERNAL-IP    PORT(S)          AGE
  kubernetes         ClusterIP      10.152.183.1    <none>         443/TCP          5d19h
  hellok8s-service   LoadBalancer   10.152.183.58   172.16.6.100   8081:31806/TCP   114s

# ë¸Œë¼ìš°ì €ë¡œ ì• í”Œë¦¬ì¼€ì´ì…˜ ì ‘ê·¼ 172.16.6.100:8081
curl 172.16.6.100:8081
```

